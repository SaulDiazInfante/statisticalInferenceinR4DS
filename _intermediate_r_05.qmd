# Utilities

Mastering R programming is not only about understanding its programming 
concepts. Having a solid understanding of a wide range of R functions is also 
important. This chapter introduces you to many useful functions for data 
structure manipulation, regular expressions, and working with times and dates.

## Mathematical utilities
Have another look at some useful math functions that R features:

- `abs()`: Calculate the absolute value.
- `sum()`: Calculate the sum of all the values in a data structure.
- `mean()`: Calculate the arithmetic mean.
- `round()`: Round the values to 0 decimal places by default. Try out ?round in 
the console for variations of `round()` and ways to change the number of digits 
to round to.

As a data scientist in training, you've estimated a regression model on the 
sales data for the past six months. After evaluating your model, you see that 
the training error of your model is quite regular, showing both positive and 
negative values. A vector `errors` containing the error values has been 
pre-defined for you.

### Instructions `100 XP` {.unnumbered}

Calculate the sum of the absolute rounded values of the training errors. 
You can work in parts, or with a single one-liner. There's no need to store the 
result in a variable, just have R print it.

 ```{.r filename=ex_043.R}
 # The errors vector has already been defined for you
errors <- c(1.9, -2.6, 4.0, -9.5, -3.4, 7.3)

# Sum of absolute rounded values of errors
sum(abs(round(errors)))
```
## Find the error

We went ahead and pre-loaded some code for you, but there's still an error. Can
you trace it and fix it?

In times of despair, help with functions such as sum() and rev() are a single 
command away; simply execute the code ?sum and ?rev.

### Instructions `100 XP` {.unnumbered}

Fix the error by including code on the last line. Remember: you want to call 
`mean()` only once!

```{.r filename="ex_044.R"}
# Don't edit these two lines
vec1 <- c(1.5, 2.5, 8.4, 3.7, 6.3)
vec2 <- rev(vec1)

# Fix the error
mean(abs(vec1))
```
## Data Utilities

R features a bunch of functions to juggle around with data structures::

- seq(): Generate sequences, by specifying the from, to, and by arguments.
- rep(): Replicate elements of vectors and lists.
- sort(): Sort a vector in ascending order. Works on numerics, but also on character strings and logicals.
- rev(): Reverse the elements in a data structures for which reversal is defined.
- str(): Display the structure of any R object.
- append(): Merge vectors or lists.
- is.*(): Check for the class of an R object.
- as.*(): Convert an R object from one class to another.
- unlist(): Flatten (possibly embedded) lists to produce a vector.

Remember the social media profile views data? Your LinkedIn and Facebook view 
counts for the last seven days have been pre-defined as lists.

### Instructions `100 XP` {.unnumbered}

- Convert both linkedin and facebook lists to a vector, and store them as 
`li_vec` and fb_vec respectively.
- Next, append fb_vec to the li_vec (Facebook data comes last). Save the result 
as social_vec.
- Finally, sort social_vec from high to low. Print the resulting vector.

```{.r filename="ex_045.R"}
# The linkedin and facebook lists have already been created for you
linkedin <- list(16, 9, 13, 5, 2, 17, 14)
facebook <- list(17, 7, 5, 16, 8, 13, 14)

# Convert linkedin and facebook to a vector: li_vec and fb_vec
li_vec <- unlist(linkedin)
fb_vec <- unlist(facebook)

# Append fb_vec to li_vec: social_vec
social_vec <- append(li_vec, fb_vec)

# Sort social_vec
print(sort(social_vec, decreasing=TRUE))

```
## Find the error (2)

Just as before, let's switch roles. It's up to you to see what unforgivable 
mistakes we've made. Go fix them!

### Instructions `100 XP` {.unnumbered}

Correct the expression. Make sure that your fix still uses the functions
`rep()` and `seq()`.

```{.r filename="ex_046.R"}
# Fix me
rep(seq(1, 7, by = 2), times = 7)
```

## Beat Gauss using R
There is a popular story about young Gauss. As a pupil, he had a lazy teacher 
who wanted to keep the classroom busy by having them add up the numbers 
1 to 100. Gauss came up with an answer almost instantaneously, 5050. 
On the spot, he had developed a formula for calculating the sum of an arithmetic
series. There are more general formulas for calculating the sum of an arithmetic
series with different starting values and increments. Instead of deriving such
a formula, why not use R to calculate the sum of a sequence?

### Instructions `100 XP` {.unnumbered}

- Using the function `seq()`, create a sequence that ranges from 1 to 500 in 
increments of 3. Assign the resulting vector to a variable `seq1`.
- Again with the function `seq()`, create a sequence that ranges from 1200 to 
900 in increments of -7. Assign it to a variable `seq2`.
- Calculate the total sum of the sequences, either by using the `sum()` function
twice and adding the two results, or by first concatenating the sequences and
then using the `sum()` function once. Print the result to the console.

```{.r filename="ex_047.R"}
# Create first sequence: seq1
seq1 <- seq(1, 500, by = 3)

# Create second sequence: seq2
seq2 <- seq(1200, 900, by = -7)

# Calculate total sum of the sequences
print(sum(seq1) + sum(seq2))
```
## grepl & grep
In their most basic form, regular expressions can be used to see whether a 
pattern exists inside a character string or a vector of character strings. For 
this purpose, you can use:

`grepl()`, which returns `TRUE` when a pattern is found in the corresponding 
character string.
`grep()`, which returns a vector of indices of the character strings that 
contains the pattern.
Both functions need a pattern and an `x` argument, where pattern is the regular
expression you want to match for, and the `x` argument is the character vector
from which matches should be sought.

In this and the following exercises, you'll be querying and manipulating a 
character vector of email addresses! The vector emails has been pre-defined so
 you can begin with the instructions straight away!

### Instructions `100 XP` {.unnumbered}

- Use `grepl()` to generate a vector of logicals that indicates whether these 
email addresses contain `"edu"`. Print the result to the output.
- Do the same thing with `grep()`, but this time save the resulting indexes in a 
variable hits.
- Use the variable hits to select from the emails vector only the emails that 
contain `"edu"`.

```{.r filename="ex_48.R"}
# The emails vector has already been defined for you
emails <- 
    c(
        "john.doe@ivyleague.edu",
        "education@world.gov",
        "dalai.lama@peace.org",
        "invalid.edu",
        "quant@bigdatacollege.edu",
        "cookie.monster@sesame.tv"
    )

# Use grepl() to match for "edu"
print(grepl('edu', emails))

# Use grep() to match for "edu", save result to hits
hits <- grep('edu', emails)

# Subset emails using hits
emails[hits]
```
## grepl & grep (2)

You can use the caret, ^, and the dollar sign, $ to match the content located 
in the start and end of a string, respectively. This could take us one step
closer to a correct pattern for matching only the ".edu" email addresses from
our list of emails. But there's more that can be added to make the pattern more
robust:

- @, because a valid email must contain an at-sign.
- .* , which matches any character (.) zero or more times (*). Both the dot and 
the asterisk are metacharacters. You can use them to match any character 
between the at-sign and the ".edu" portion of an email address.
- `\\.edu$`, to match the ".edu" part of the email at the end of the string. 
The `\\` part escapes the dot: it tells R that you want to use the `.` as an 
actual character.

### Instructions `100 XP` {.unnumbered}

- Use `grepl()` with the more advanced regular expression to return a logical 
vector. Simply print the result.
- Do a similar thing with `grep()` to create a vector of indices. 
Store the result in the variable `hits`.
- Use `emails[hits]` again to subset the `emails` vector.


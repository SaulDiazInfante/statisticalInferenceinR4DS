{
  "hash": "bf7b09e6e726dd179315f996d65ae0b7",
  "result": {
    "markdown": "# Utilities\n\nMastering R programming is not only about understanding its programming \nconcepts. Having a solid understanding of a wide range of R functions is also \nimportant. This chapter introduces you to many useful functions for data \nstructure manipulation, regular expressions, and working with times and dates.\n\n## Mathematical utilities\nHave another look at some useful math functions that R features:\n\n- `abs()`: Calculate the absolute value.\n- `sum()`: Calculate the sum of all the values in a data structure.\n- `mean()`: Calculate the arithmetic mean.\n- `round()`: Round the values to 0 decimal places by default. Try out ?round in \nthe console for variations of `round()` and ways to change the number of digits \nto round to.\n\nAs a data scientist in training, you've estimated a regression model on the \nsales data for the past six months. After evaluating your model, you see that \nthe training error of your model is quite regular, showing both positive and \nnegative values. A vector `errors` containing the error values has been \npre-defined for you.\n\n### Instructions `100 XP` {.unnumbered}\n\nCalculate the sum of the absolute rounded values of the training errors. \nYou can work in parts, or with a single one-liner. There's no need to store the \nresult in a variable, just have R print it.\n\n ```{.r filename=ex_043.R}\n # The errors vector has already been defined for you\nerrors <- c(1.9, -2.6, 4.0, -9.5, -3.4, 7.3)\n\n# Sum of absolute rounded values of errors\nsum(abs(round(errors)))\n```\n## Find the error\n\nWe went ahead and pre-loaded some code for you, but there's still an error. Can\nyou trace it and fix it?\n\nIn times of despair, help with functions such as sum() and rev() are a single \ncommand away; simply execute the code ?sum and ?rev.\n\n### Instructions `100 XP` {.unnumbered}\n\nFix the error by including code on the last line. Remember: you want to call \n`mean()` only once!\n\n```{.r filename=\"ex_044.R\"}\n# Don't edit these two lines\nvec1 <- c(1.5, 2.5, 8.4, 3.7, 6.3)\nvec2 <- rev(vec1)\n\n# Fix the error\nmean(abs(vec1))\n```\n## Data Utilities\n\nR features a bunch of functions to juggle around with data structures::\n\n- seq(): Generate sequences, by specifying the from, to, and by arguments.\n- rep(): Replicate elements of vectors and lists.\n- sort(): Sort a vector in ascending order. Works on numerics, but also on character strings and logicals.\n- rev(): Reverse the elements in a data structures for which reversal is defined.\n- str(): Display the structure of any R object.\n- append(): Merge vectors or lists.\n- is.*(): Check for the class of an R object.\n- as.*(): Convert an R object from one class to another.\n- unlist(): Flatten (possibly embedded) lists to produce a vector.\n\nRemember the social media profile views data? Your LinkedIn and Facebook view \ncounts for the last seven days have been pre-defined as lists.\n\n### Instructions `100 XP` {.unnumbered}\n\n- Convert both linkedin and facebook lists to a vector, and store them as \n`li_vec` and fb_vec respectively.\n- Next, append fb_vec to the li_vec (Facebook data comes last). Save the result \nas social_vec.\n- Finally, sort social_vec from high to low. Print the resulting vector.\n\n```{.r filename=\"ex_045.R\"}\n# The linkedin and facebook lists have already been created for you\nlinkedin <- list(16, 9, 13, 5, 2, 17, 14)\nfacebook <- list(17, 7, 5, 16, 8, 13, 14)\n\n# Convert linkedin and facebook to a vector: li_vec and fb_vec\nli_vec <- unlist(linkedin)\nfb_vec <- unlist(facebook)\n\n# Append fb_vec to li_vec: social_vec\nsocial_vec <- append(li_vec, fb_vec)\n\n# Sort social_vec\nprint(sort(social_vec, decreasing=TRUE))\n\n```\n## Find the error (2)\n\nJust as before, let's switch roles. It's up to you to see what unforgivable \nmistakes we've made. Go fix them!\n\n### Instructions `100 XP` {.unnumbered}\n\nCorrect the expression. Make sure that your fix still uses the functions\n`rep()` and `seq()`.\n\n```{.r filename=\"ex_046.R\"}\n# Fix me\nrep(seq(1, 7, by = 2), times = 7)\n```\n\n## Beat Gauss using R\nThere is a popular story about young Gauss. As a pupil, he had a lazy teacher \nwho wanted to keep the classroom busy by having them add up the numbers \n1 to 100. Gauss came up with an answer almost instantaneously, 5050. \nOn the spot, he had developed a formula for calculating the sum of an arithmetic\nseries. There are more general formulas for calculating the sum of an arithmetic\nseries with different starting values and increments. Instead of deriving such\na formula, why not use R to calculate the sum of a sequence?\n\n### Instructions `100 XP` {.unnumbered}\n\n- Using the function `seq()`, create a sequence that ranges from 1 to 500 in \nincrements of 3. Assign the resulting vector to a variable `seq1`.\n- Again with the function `seq()`, create a sequence that ranges from 1200 to \n900 in increments of -7. Assign it to a variable `seq2`.\n- Calculate the total sum of the sequences, either by using the `sum()` function\ntwice and adding the two results, or by first concatenating the sequences and\nthen using the `sum()` function once. Print the result to the console.\n\n```{.r filename=\"ex_047.R\"}\n# Create first sequence: seq1\nseq1 <- seq(1, 500, by = 3)\n\n# Create second sequence: seq2\nseq2 <- seq(1200, 900, by = -7)\n\n# Calculate total sum of the sequences\nprint(sum(seq1) + sum(seq2))\n```\n## grepl & grep\nIn their most basic form, regular expressions can be used to see whether a \npattern exists inside a character string or a vector of character strings. For \nthis purpose, you can use:\n\n`grepl()`, which returns `TRUE` when a pattern is found in the corresponding \ncharacter string.\n`grep()`, which returns a vector of indices of the character strings that \ncontains the pattern.\nBoth functions need a pattern and an `x` argument, where pattern is the regular\nexpression you want to match for, and the `x` argument is the character vector\nfrom which matches should be sought.\n\nIn this and the following exercises, you'll be querying and manipulating a \ncharacter vector of email addresses! The vector emails has been pre-defined so\n you can begin with the instructions straight away!\n\n### Instructions `100 XP` {.unnumbered}\n\n- Use `grepl()` to generate a vector of logicals that indicates whether these \nemail addresses contain `\"edu\"`. Print the result to the output.\n- Do the same thing with `grep()`, but this time save the resulting indexes in a \nvariable hits.\n- Use the variable hits to select from the emails vector only the emails that \ncontain `\"edu\"`.\n\n```{.r filename=\"ex_48.R\"}\n# The emails vector has already been defined for you\nemails <- \n    c(\n        \"john.doe@ivyleague.edu\",\n        \"education@world.gov\",\n        \"dalai.lama@peace.org\",\n        \"invalid.edu\",\n        \"quant@bigdatacollege.edu\",\n        \"cookie.monster@sesame.tv\"\n    )\n\n# Use grepl() to match for \"edu\"\nprint(grepl('edu', emails))\n\n# Use grep() to match for \"edu\", save result to hits\nhits <- grep('edu', emails)\n\n# Subset emails using hits\nemails[hits]\n```\n## grepl & grep (2)\n\nYou can use the caret, ^, and the dollar sign, $ to match the content located \nin the start and end of a string, respectively. This could take us one step\ncloser to a correct pattern for matching only the \".edu\" email addresses from\nour list of emails. But there's more that can be added to make the pattern more\nrobust:\n\n- @, because a valid email must contain an at-sign.\n- .* , which matches any character (.) zero or more times (*). Both the dot and \nthe asterisk are metacharacters. You can use them to match any character \nbetween the at-sign and the \".edu\" portion of an email address.\n- `\\\\.edu$`, to match the \".edu\" part of the email at the end of the string. \nThe `\\\\` part escapes the dot: it tells R that you want to use the `.` as an \nactual character.\n\n### Instructions `100 XP` {.unnumbered}\n\n- Use `grepl()` with the more advanced regular expression to return a logical \nvector. Simply print the result.\n- Do a similar thing with `grep()` to create a vector of indices. \nStore the result in the variable `hits`.\n- Use `emails[hits]` again to subset the `emails` vector.\n\n\n::: {.cell filename='ex_048.R'}\n\n```{.r .cell-code}\n# The emails vector has already been defined for you\nemails <- c(\n    \"john.doe@ivyleague.edu\",\n    \"education@world.gov\",\n    \"dalai.lama@peace.org\",\n    \"invalid.edu\",\n    \"quant@bigdatacollege.edu\",\n    \"cookie.monster@sesame.tv\"\n)\ngrepl(\"@.*\\\\.edu$\", emails)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nhits <- grep(\"@.*\\\\.edu$\", emails)\nemails[hits]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"john.doe@ivyleague.edu\"   \"quant@bigdatacollege.edu\"\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}